# Shared helpers for firmware tooling

log() {
  local msg="$1"
  echo "[AGENT] $msg" >&2
}

fail() {
  local msg="$1"
  echo "[AGENT][FAIL] $msg" >&2
  exit 1
}

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    fail "missing command: $1"
  fi
}

get_repo_root() {
  if [[ -n "${REPO_ROOT:-}" && -d "${REPO_ROOT}/.git" ]]; then
    printf '%s' "$REPO_ROOT"
    return 0
  fi
  git -C "$(dirname "${BASH_SOURCE[0]}")/../.." rev-parse --show-toplevel
}

get_fw_root() {
  if [[ -n "${FW_ROOT:-}" && -d "$FW_ROOT" ]]; then
    printf '%s' "$FW_ROOT"
    return 0
  fi
  printf '%s' "$(get_repo_root)/hardware/firmware"
}

# Gate: build (strict, log)
build_gate() {
  log "Build gate: $*"
  "$@" 2>&1 | tee "${AGENT_LOG:-logs/agent_build.log}" || fail "Build failed ($*)"
}

# Gate: smoke (strict, log)
smoke_gate() {
  log "Smoke gate: $*"
  "$@" 2>&1 | tee "${AGENT_LOG:-logs/agent_smoke.log}" || fail "Smoke failed ($*)"
}

# Gate: artefact (strict copy)
artefact_gate() {
  local src="$1"
  local dest="$2"
  log "Artefact: $src -> $dest"
  cp -a "$src" "$dest" || fail "Artefact copy failed"
}

# Gate: logs (strict copy)
logs_gate() {
  local src="$1"
  local dest="$2"
  log "Logs: $src -> $dest"
  cp -a "$src" "$dest" || fail "Logs copy failed"
}

# Fast loop (parallel)
fast_loop() {
  log "Fast loop: $*"
  parallel "$@"
}

# Automated artefact/log analysis
analyse_artefacts_logs() {
  local fw_root
  fw_root=$(get_fw_root)
  local artefacts_dir="${1:-$fw_root/artifacts/rc_live}"
  local logs_dir="${2:-$fw_root/logs}"
  echo "[AGENT] Analyse artefacts/logs..."
  local last_flash_dir
  last_flash_dir=$(ls -1dt "$artefacts_dir"/flash-* 2>/dev/null | head -n1)
  if [[ -n "$last_flash_dir" && -f "$last_flash_dir/ports_resolve.json" ]]; then
    echo "--- Last port map (ports_resolve.json) ---"
    if command -v jq >/dev/null 2>&1; then
      jq . "$last_flash_dir/ports_resolve.json" || cat "$last_flash_dir/ports_resolve.json"
    else
      cat "$last_flash_dir/ports_resolve.json"
    fi
  else
    echo "[WARN] No ports_resolve.json artefact found."
  fi
  local build_log="$logs_dir/agent_build.log"
  if [[ -f "$build_log" ]]; then
    echo "--- Build summary (agent_build.log) ---"
    grep -E 'SUCCESS|FAIL|error|panic|Guru Meditation|rst:|abort|assert' "$build_log" || echo "[OK] No critical failure detected."
  else
    echo "[WARN] No build log found."
  fi
  find "$logs_dir" -maxdepth 1 -type f -name 'smoke_*' -print0 2>/dev/null \
    | xargs -0 ls -1t 2>/dev/null \
    | head -n 5 \
    | while IFS= read -r logf; do
        [[ -n "$logf" ]] || continue
        echo "--- Analyse $logf ---"
        grep -E 'FAIL|error|panic|Guru Meditation|rst:|abort|assert' "$logf" || echo "[OK] No critical failure detected."
      done
  echo "[AGENT] Analyse artefacts/logs done."
}

# Sync audit report
generate_sync_report() {
  local output_path="$1"
  local repo_root
  repo_root=$(get_repo_root)
  local fw_root
  fw_root=$(get_fw_root)
  local out="${output_path:-$fw_root/logs/audit_sync_report.md}"
  local base_ref
  base_ref=$(git -C "$repo_root" symbolic-ref --short refs/remotes/origin/HEAD 2>/dev/null || true)
  if [[ -z "$base_ref" ]]; then
    base_ref="origin/main"
  fi
  local now
  now=$(date -u +"%Y-%m-%d")
  local diffstat
  diffstat=$(git -C "$repo_root" diff --stat "$base_ref...HEAD" 2>/dev/null || true)
  local totals
  totals=$(printf '%s\n' "$diffstat" | tail -n1)
  local top_files
  top_files=$(git -C "$repo_root" diff --stat --stat-count=25 "$base_ref...HEAD" 2>/dev/null || true)
  mkdir -p "$(dirname "$out")"
  cat > "$out" <<EOF
# Sync audit report

Date: $now
Base: $base_ref
Branch: $(git -C "$repo_root" rev-parse --abbrev-ref HEAD)

## Summary
- Totals: ${totals:-no changes detected}

## Top changes (stat)
${top_files:-no diffstat available}

## Notes
- Generated by tools/dev/agent_utils.sh
- Scope: repo root and hardware/firmware tree
EOF
  log "Sync report written: $out"
}

# Cleanup old logs/artefacts
cleanup_audit_files() {
  local fw_root
  fw_root=$(get_fw_root)
  local logs_dir="${1:-$fw_root/logs}"
  local artifacts_dir="${2:-$fw_root/artifacts/rc_live}"
  local keep_days="${ZACUS_CLEANUP_KEEP_DAYS:-7}"
  local stamp
  stamp=$(date -u +"%Y%m%d-%H%M%S")
  local logs_archive="$logs_dir/archive/$stamp"
  local artifacts_archive="$fw_root/artifacts/archive/$stamp"
  mkdir -p "$logs_archive" "$artifacts_archive"
  local moved=0
  local log_count
  log_count=$(find "$logs_dir" -type f -mtime +"$keep_days" -print 2>/dev/null | wc -l | tr -d ' ')
  if [[ "$log_count" -gt 0 ]]; then
    find "$logs_dir" -type f -mtime +"$keep_days" -print0 2>/dev/null \
      | while IFS= read -r -d '' f; do
          mv "$f" "$logs_archive/"
        done
    moved=1
  fi
  local artifacts_count
  artifacts_count=$(find "$artifacts_dir" -mindepth 1 -maxdepth 1 -mtime +"$keep_days" -print 2>/dev/null | wc -l | tr -d ' ')
  if [[ "$artifacts_count" -gt 0 ]]; then
    find "$artifacts_dir" -mindepth 1 -maxdepth 1 -mtime +"$keep_days" -print0 2>/dev/null \
      | while IFS= read -r -d '' f; do
          mv "$f" "$artifacts_archive/"
        done
    moved=1
  fi
  if [[ "$moved" == "0" ]]; then
    log "cleanup: nothing to archive (keep_days=$keep_days)"
  else
    log "cleanup: archived logs to $logs_archive"
    log "cleanup: archived artefacts to $artifacts_archive"
  fi
}

# Codex CLI check (prompts + command)
codex_cli_audit() {
  local fw_root
  fw_root=$(get_fw_root)
  local prompt_dir="$fw_root/tools/dev/codex_prompts"
  if command -v codex >/dev/null 2>&1; then
    log "codex: found"
  else
    log "codex: missing"
  fi
  if [[ -d "$prompt_dir" ]]; then
    log "codex prompts: $(ls -1 "$prompt_dir"/*.prompt*.md 2>/dev/null | wc -l | tr -d ' ') files"
  else
    log "codex prompts: missing dir $prompt_dir"
  fi
}

# Audit drivers per platform (placeholders for now)
drivers_audit() {
  local platform="$1"
  log "Audit drivers for $platform"
  case "$platform" in
    esp32dev|esp32_release)
      local drivers_ok=1
      local fw_root
      fw_root=$(get_fw_root)
      local req_files=(
        "$fw_root/esp32_audio/src/services/ui_serial/ui_serial.cpp"
        "$fw_root/esp32_audio/src/services/serial/serial_router.cpp"
        "$fw_root/protocol/ui_link_v2.h"
      )
      local f
      for f in "${req_files[@]}"; do
        if [[ ! -f "$f" ]]; then
          log "[WARN] missing driver file: $f"
          drivers_ok=0
        fi
      done
      if [[ "$drivers_ok" == "1" ]]; then
        log "[OK] drivers ESP32 ($platform) files present"
      fi
      ;;
    esp8266_oled)
      local drivers_ok=1
      local fw_root
      fw_root=$(get_fw_root)
      local req_files=(
        "$fw_root/ui/esp8266_oled/src/gfx/u8g2_display_backend.cpp"
        "$fw_root/ui/esp8266_oled/src/core/stat_parser.cpp"
        "$fw_root/ui/esp8266_oled/src/core/text_parser.cpp"
      )
      local f
      for f in "${req_files[@]}"; do
        if [[ ! -f "$f" ]]; then
          log "[WARN] missing driver file: $f"
          drivers_ok=0
        fi
      done
      if [[ "$drivers_ok" == "1" ]]; then
        log "[OK] drivers ESP8266 ($platform) files present"
      fi
      ;;
    ui_rp2040_ili9488|ui_rp2040_ili9486)
      local drivers_ok=1
      local fw_root
      fw_root=$(get_fw_root)
      local req_files=(
        "$fw_root/ui/rp2040_tft/src/lvgl_port.cpp"
        "$fw_root/ui/rp2040_tft/src/ui_renderer.cpp"
        "$fw_root/ui/rp2040_tft/src/uart_link.cpp"
      )
      local f
      for f in "${req_files[@]}"; do
        if [[ ! -f "$f" ]]; then
          log "[WARN] missing driver file: $f"
          drivers_ok=0
        fi
      done
      if [[ "$drivers_ok" == "1" ]]; then
        log "[OK] drivers RP2040 ($platform) files present"
      fi
      ;;
    *)
      fail "unknown platform for drivers_audit: $platform" ;;
  esac
}

# Audit tests per platform (placeholders for now)
tests_audit() {
  local platform="$1"
  log "Audit tests for $platform"
  case "$platform" in
    esp32dev|esp32_release)
      local fw_root
      fw_root=$(get_fw_root)
      local smoke_script="$fw_root/esp32_audio/tools/qa/story_v2_ci.sh"
      local rc_script="$fw_root/esp32_audio/tools/qa/live_story_v2_smoke.sh"
      local ok=1
      if [[ ! -f "$smoke_script" ]]; then
        log "[WARN] missing smoke script: $smoke_script"
        ok=0
      fi
      if [[ ! -f "$rc_script" ]]; then
        log "[WARN] missing RC smoke script: $rc_script"
        ok=0
      fi
      if [[ "$ok" == "1" ]]; then
        log "[OK] tests ESP32 ($platform) scripts present"
      fi
      ;;
    esp8266_oled)
      local fw_root
      fw_root=$(get_fw_root)
      local suite="$fw_root/tools/test/run_serial_suite.py"
      local sim="$fw_root/tools/test/ui_link_sim.py"
      local ok=1
      if [[ ! -f "$suite" ]]; then
        log "[WARN] missing serial suite: $suite"
        ok=0
      fi
      if [[ ! -f "$sim" ]]; then
        log "[WARN] missing UI link sim: $sim"
        ok=0
      fi
      if [[ "$ok" == "1" ]]; then
        log "[OK] tests ESP8266 ($platform) scripts present"
      fi
      ;;
    ui_rp2040_ili9488|ui_rp2040_ili9486)
      local fw_root
      fw_root=$(get_fw_root)
      local runbook="$fw_root/ui/rp2040_tft/README.md"
      local spec="$fw_root/ui/rp2040_tft/UI_SPEC.md"
      local ok=1
      if [[ ! -f "$runbook" ]]; then
        log "[WARN] missing runbook: $runbook"
        ok=0
      fi
      if [[ ! -f "$spec" ]]; then
        log "[WARN] missing UI spec: $spec"
        ok=0
      fi
      if [[ "$ok" == "1" ]]; then
        log "[OK] tests RP2040 ($platform) docs present"
      fi
      ;;
    *)
      fail "unknown platform for tests_audit: $platform" ;;
  esac
}

# --- Menu TUI helpers ---
ZACUS_LANG=${ZACUS_LANG:-}
if [[ -z "$ZACUS_LANG" ]]; then
  case "${LANG:-}" in
    fr*|FR*) ZACUS_LANG=fr ;;
    en*|EN*) ZACUS_LANG=en ;;
    *) ZACUS_LANG=fr ;;
  esac
fi

menu_str() {
  local key="$1"
  case "$ZACUS_LANG" in
    fr)
      case "$key" in
        menu_title) echo "Zacus CLI" ;;
        opt_bootstrap) echo "Lancer RC Live" ;;
        opt_build) echo "Flasher + RC Live" ;;
        opt_flash) echo "RC Live + AutoFix" ;;
        opt_logs) echo "Voir les logs" ;;
        opt_help) echo "Aide" ;;
        opt_quit) echo "Quitter" ;;
        pause) echo "Appuyez sur une touche pour revenir au menu..." ;;
        bye) echo "Au revoir !" ;;
        *) echo "$key" ;;
      esac
      ;;
    en)
      case "$key" in
        menu_title) echo "Zacus CLI" ;;
        opt_bootstrap) echo "Run RC Live" ;;
        opt_build) echo "Flash + RC Live" ;;
        opt_flash) echo "RC Live + AutoFix" ;;
        opt_logs) echo "Show logs" ;;
        opt_help) echo "Help" ;;
        opt_quit) echo "Quit" ;;
        pause) echo "Press any key to return to menu..." ;;
        bye) echo "Goodbye!" ;;
        *) echo "$key" ;;
      esac
      ;;
    *)
      echo "$key" ;;
  esac
}

menu_select() {
  local title="$1"
  shift
  local options=("$@")
  local n=${#options[@]}
  local tui_cmd=""
  if command -v fzf >/dev/null 2>&1; then
    tui_cmd="fzf"
  elif command -v dialog >/dev/null 2>&1; then
    tui_cmd="dialog"
  elif command -v whiptail >/dev/null 2>&1; then
    tui_cmd="whiptail"
  fi
  if [[ "$tui_cmd" == "fzf" ]]; then
    local reversed=()
    for ((i=n-1; i>=0; i--)); do reversed+=("$((i+1)): ${options[i]}"); done
    local choice
    choice=$(printf '%s\n' "${reversed[@]}" | fzf --ansi --prompt="‚ùØ $title : " --header="[Arrows] navigate, [Enter] select, [Esc] exit" --height=15 --border)
    [[ -z "$choice" ]] && echo 0 && return
    echo "${choice%%:*}"
  elif [[ "$tui_cmd" == "dialog" || "$tui_cmd" == "whiptail" ]]; then
    local menu_args=()
    for ((i=0; i<n; i++)); do menu_args+=($((i+1)) "${options[i]}"); done
    local choice
    if [[ "$tui_cmd" == "dialog" ]]; then
      choice=$(dialog --clear --title "$title" --menu "Select:" 20 70 15 "${menu_args[@]}" 3>&1 1>&2 2>&3)
    else
      choice=$(whiptail --title "$title" --menu "Select:" 20 70 15 "${menu_args[@]}" 3>&1 1>&2 2>&3)
    fi
    [[ -z "$choice" ]] && echo 0 && return
    echo "$choice"
  else
    echo -e "\033[1;33m$title\033[0m"
    for ((i=0; i<n; i++)); do echo "  $((i+1))) ${options[i]}"; done
    echo -en "Selection (or Enter to cancel): "
    read -r idx
    [[ -z "$idx" ]] && echo 0 && return
    if [[ "$idx" =~ ^[0-9]+$ ]] && (( idx >= 1 && idx <= n )); then
      echo "$idx"
    else
      echo 0
    fi
  fi
}
